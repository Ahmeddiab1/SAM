/*@

<br><br>
This macro helps the user determine the optimal array size and layout on a land of fixed dimensions. The array placement is optimized with respect to 3 main strategies:
<br><br> 
 
<ol>
<li> Maximizing Annual Energy Production (AEP)
<li> Maximizing Net Present Value (NPV) of System 
<li> Maximizing Energy Yield (kWh/kW) of the System
</ol>
@*/
 
 
//Macro User Interface Widgets
//@ name=length;type=number;label=Enter the Length of Field or Rooftop (m):;value=100
//@ name=width;type=number;label=Enter the width of Field or Rooftop (m):;value=50
//@ name=setback;type=number;label=Enter the setback (in m) from edges (this is the area over which modules cannot be placed):;value=1 
//@ name=max_gcr;type=number;label=Enter the maximum Ground Coverage Ratio (GCR) over which modules can be placed:;value=1 
//@ name=min_gcr;type=number;label=Enter the minimum Ground Coverage Ratio (GCR) over which modules can be placed (value cannot equal 0):;value=0.1 
//@ name=gcr_steps;type=number;label=Enter the increments you would like to iterate GCR over:;value=0.1
//@ name=max_tilt;type=number;label=Enter the maximum allowable (fixed) tilt angle (in Degrees):;value=90
//@ name=min_tilt;type=number;label=Enter the minimum allowable (fixed) tilt angle (in Degrees):;value=0
//@ name=tilt_steps;type=number;label=Enter the increments you would like to iterate tilt angle over (in Degrees):;value=10

///////////////////////////////////**** USER DEFINED INPUTS ****///////////////////////////////////

//User Defined Inputs:
length = macro.length ; 					//Length of field (m)
width = macro.width;						//Width of fiel (m)
setback = macro.setback;					//Distance from edge of land that is off limits for placement of modules (m)
	effective_length = length - setback;		//(Calculated Value) Actual length of the field that is available for placement of modules (m)
	effective_width = width - setback;			//(Calculated Value) Actual width of the field that is available for placement of modules	(m)
	area = effective_length * effective_width; 	//(Calculated Value) Total effective land area (in m^2)
max_gcr = macro.max_gcr;					//Allow the user to input max GCR
min_gcr = macro.min_gcr;					//Allow the user to input min GCR
gcr_steps = macro.gcr_steps;				//Allow the  user to input the increments of GCR they want to calculate over
max_tilt = macro.max_tilt;					//Allow the user to input max tilt angle
min_tilt = macro.min_tilt;					//Allow the user to input min tilt angel
tilt_steps = macro.tilt_steps;				//Allow the user the input the increments of tilt angle they want to calculate over


//Acres to m^2 conversion:
//land_area = 0.223;					//Effective land area after factoring in setbacks (in acres)
//area = land_area/0.0002471 ;			//Total land area in m^2

acreage = area*0.0002471;



///////////////////////////////////**** DEFINING PLACEHOLDER VARIABLES ****///////////////////////////////////

//Placeholders:
max_energy = 0;						//Placeholder for maximum Annual Energy Production (AEP)
optimum_gcr = 0 ;					//Placeholder for the optimum GCR that yields maximum AEP 
optimum_tilt = 0;					//Placeholder for the panel tilt angle that yields maximum AEP
max_system_size = 0;				//Placeholder for the system size that produces maximum annual energy
energy_npv = 0;						//Placeholder for the npv at max energy configuration
max_npv = -9999999999;				//PLaceholder for the max npv
system_size_npv = 0;				//Placeholder for the system size at max npv
gcr_npv = 0;						//placeholder for the gcr at max npv
tilt_npv = 0;						//Placeholder for the tilt at max npv
aep_npv = 0;						//Placeholder for aep at max NPV
max_yield = 0;						//Placeholder for max energy yield of system
gcr_yield = 0;						//Placeholder for gcr at max energy yield of system
tilt_yield = 0;						//Placeholder for tilt at max energy yield of system
system_size_yield = 0;				//Placeholder for system size at max energy yield of system
aep_yield = 0;						//Placeholder for AEP at max energy yield of system

//Placeholders for storing layout configuration at max AEP: 
nmody =  get('subarray1_nmody');	//This currently can only be changed within the active case running on SAM
aep_nmodx = 0;
aep_nrows = 0;
aep_row_spacing = 0;
aep_total_modules = 0;

//Placeholders for storing layout configuration at max NPV:
npv_nmodx = 0;
npv_nrows = 0;
npv_row_spacing = 0;
npv_total_modules = 0;

//Placeholders for storing layout configuration at max Energy Yield:
yield_nmodx = 0;
yield_nrows = 0;
yield_row_spacing = 0;
yield_total_modules = 0;



///////////////////////////////////**** ARRAY PLACEMENT ****///////////////////////////////////

outln("\n\tOptimizing Array Layout for given ranges of GCR and Tilt over area of " + acreage + " acres...");

//function for calculating system size 
system_sizer = define(gcr) {
		
		module_model = get('module_model');
		module_power = 0;
		
		if (module_model == 0){
			module_power = get('spe_power');
		}
		else if (module_model == 1){
            module_power = get('cec_p_mp_ref');
		}
		else if (module_model == 2){
			module_power = get('6par_pmp');
		}
		else if (module_model == 3){
			module_power = get('snl_ref_pmp');
		}
		else if (module_model == 4){
			module_power = get('sd11par_Pmp0');
		}

		
		module_area = get('module_area');
		set('subarray1_gcr', gcr);
		set('desired_size', gcr*(area/module_area)*(module_power/1000));
		system_size = get('desired_size');
		return system_size;
	};

i = 0;	
for (gcr = min_gcr ; gcr <= max_gcr ; gcr = gcr + gcr_steps) { 
	system_size[i] = system_sizer(gcr);
	i = i + 1;
}

//Variable to keep a tab of rows in the loop
if (get('subarray1_mod_orient') == 1) {			//if module orientation is landscape, then length of panel is used in calculation length of row
	module_length = get('module_length');		//Length of 1 module
	bottom_length = module_length;				//Initial length of bottom row of modules 
	set('subarray1_nmodx', 1);
}
elseif (get('subarray1_mod_orient') == 0) { 	//If module orientation is portrait, then width of panel is used in calculation length of row		
	module_length = get('module_width');		//Length of 1 module
	bottom_length = module_length;				//Initial length of bottom row of modules 
	set('subarray1_nmodx', 1);
}


p = 0;
n = 0;
i = 0;

//Fitting modules along length of field:
for(gcr = min_gcr ; gcr <= max_gcr ; gcr = gcr + gcr_steps) {						//For loop to iterate over the entire range of (user input) GCRs, to make sure module placement along length and width of the field is in sync with the respective GCRs. So, for instance, even though the field length could accomodate a longer row of modules, number of modules in each row and alongside row is restricted.	
	
	
	set('desired_size', system_size[i]);	
	set('subarray1_gcr', gcr);
	n = to_int((effective_length/module_length) );
	set('subarray1_nmodx',n);
		
	while(get('ui_subarray1_nrows') <1){						//Reduce the number of panels along the bottom of the row if the GCR limit is exceeded
		n = n - 1;
		set('subarray1_nmodx', n);
	}
	
	if(get('ui_subarray1_nrows') < 1 || n == 0) {
		outln("\tError: You are trying to place too many panels along side of each row. Consider reducing the number of panels along side each row.");
		exit;
	}
		
	bottom_modules[p] = n;
	set('subarray1_nmodx', bottom_modules[p]);
	
	p = p + 1;
	i = i + 1;
}


///////////////////////////////////**** S I M U L A T I O N ****///////////////////////////////////

outln("\n\tRunning Simulations for Optimized Array Layouts at Every Combination of GCR and Tilt. This may take a minute...");

i = 0;
//Nested for loop to calculate maximum AEP, and maximum NPV
//for user input range of GCR and tilt angles
for (gcr = min_gcr ; gcr <= max_gcr ; gcr = gcr + gcr_steps) { 			//Loop for iterating over a range of GCR

	j = -1;				//counter variable to keep tab of the columns in the loop
	if(i <10) {
		set('desired_size', system_size[i]);
		set('subarray1_gcr', gcr);
		set('subarray1_nmodx', bottom_modules[i]);
		}
	else continue;
	
	for (tilt = min_tilt ; tilt <= max_tilt ; tilt = tilt + tilt_steps) {	//Loop for iterating over a range of tilt angles
		j = j + 1; 									//Variable to keep a tab of columns in the loop
		x[j] = min_tilt + (tilt_steps * j); 		//Array to store the tilt angles the user would like to iterate over
		set('subarray1_tilt', tilt);
		simulate();
		annual_energy[i][j] = get('annual_energy');
		npv[i][j] = get('npv');
		yield[i][j] = get('kwh_per_kw');
		
		//Storing the appropriate results (when calculating maximum AEP) in the respective placeholders
		if (annual_energy[i][j] > max_energy) {						
			max_energy = annual_energy[i][j] ;
			optimum_gcr = gcr;
			optimum_tilt = tilt;
			max_system_size = system_size[i];
			energy_npv = get('npv');
			aep_nmodx = get('subarray1_nmodx');
			aep_nrows = get('ui_subarray1_nrows');
			aep_row_spacing = get('ui_subarray1_row_spacing');
			aep_total_modules = get('total_modules');
		}
				
		//Storing the appropriate results when calculating maximum NPV in the respective placeholders
		if (max_npv < npv[i][j]) {
			max_npv = npv[i][j];
			gcr_npv = gcr; 
			tilt_npv = tilt;
			system_size_npv = system_size[i];
			aep_npv = annual_energy[i][j];
			npv_nmodx = get('subarray1_nmodx');
			npv_nrows = get('ui_subarray1_nrows');
			npv_row_spacing = get('ui_subarray1_row_spacing');
			npv_total_modules = get('total_modules');
		}
				
				
		//Storing the appropriate results when calculating maximum energy yield of project
		if(max_yield < yield[i][j]) {
			max_yield = yield[i][j];
			gcr_yield = gcr;
			tilt_yield = tilt;
			system_size_yield = system_size[i];
			aep_yield = annual_energy[i][j];
			yield_nmodx = get('subarray1_nmodx');
			yield_nrows = get('ui_subarray1_nrows');
			yield_row_spacing = get('ui_subarray1_row_spacing');
			yield_total_modules = get('total_modules');
		}
	}
	i = i + 1;		
}





///////////////////////////////////**** R E S U L T S ****///////////////////////////////////

str = '<html><body><h1> Summary of Results </h1><p>Reported for case: ' + active_case() + '</p>\n';

//Max AEP Results:
str += '<br><h5>System Layout for Max Annual Energy Production: </h5>';
str += '<br>Max Annual Energy Production (AEP): '+ max_energy + ' kWh';
str += '<br>Optimum GCR: ' + optimum_gcr ;
str += '<br>Optimum Tilt Angle (In Degrees): ' + optimum_tilt ; 
str += '<br>System Size That Produces Max Annual Energy Production: '+ max_system_size + ' kW';
str += '<br>NPV at max energy: $ '+ energy_npv + 'kWh';
str += '<br>Array Layout Configuration at max AEP is: ';
str += '<br>Number of modules along bottom: ' + aep_nmodx + ' modules'; 
str += '<br>Number of modules along side of each row (note: this was set by the user in the active case): ' + nmody + ' module(s)';
str += '<br>Number of rows: ' + aep_nrows + ' rows'; 
str += '<br>Row spacing estimate: ' + aep_row_spacing + ' m';
str += '<br>Total number of modules: ' + aep_total_modules + ' modules\n';

//Table for AEP Results
str += '<br><br><strong> AEP at Specified Combinations of GCR and Tilt Angles (kWH): <br></strong>';
str += '<table>'; 
str += '<table border = "1">';
str += '<th> </th>';
for (tilt = min_tilt  ; tilt <= max_tilt ; tilt = tilt + tilt_steps)
{
	str += '<th>Tilt Angle: ' + tilt + '</th>';
}

i = 0;
for (gcr = min_gcr ; gcr <= max_gcr ; gcr = gcr + gcr_steps) { 
	j = -1;
	str += '<tr>';
	str += '<th>GCR: ' + gcr + '</th>';
	for (tilt = min_tilt ; tilt <= max_tilt ; tilt = tilt + tilt_steps) {
		j = j + 1;
		if (annual_energy[i][j] == max_energy) str += '<td bgcolor = #00ff00>';
		else str += '<td>';
		str += ' ' + round(annual_energy[i][j]) + ' '; 
		str += '</td>';
	}
	i = i + 1;
	str += '</tr>'; 
}

str += '</table>';



//Max NPV Results:
str += '<br><br><h5>System Layout for Max Net Present Value: </h5>' ;
str += '<br>Max NPV = $ ' + max_npv;
str += '<br>NPV optmized GCR : ' + gcr_npv;
str +=  '<br>NPV optimized Tilt (in Degrees): ' +  tilt_npv;
str += '<br>NPV optimized System Size : '+ system_size_npv + ' kW';
str += '<br>NPV optimized AEP : '+ aep_npv + ' kWh'; 
str += '<br>Array Layout Configuration at max NPV is: ';
str += '<br>Number of modules along bottom: ' + npv_nmodx +' modules'; 
str += '<br>Number of modules along side of each row (note: this was set by the user in the active case): ' + nmody + ' module(s)';
str += '<br>Number of rows: ' + npv_nrows +' rows '; 
str += '<br>Row spacing estimate: ' + npv_row_spacing + 'm';
str += '<br>Total number of modules: ' + npv_total_modules + ' modules';

//Table for NPV Results:
str += '<br><br><strong> NPV at Specified Combinations of GCR and Tilt Angles (in $): <br></strong>';
str += '<table>'; 
str += '<table border = "1">';
str += '<th> </th>';
for (tilt = min_tilt  ; tilt <= max_tilt ; tilt = tilt + tilt_steps)
{
	str += '<th>Tilt Angle: ' + tilt + '</th>';
}

i = 0;
for (gcr = min_gcr ; gcr <= max_gcr ; gcr = gcr + gcr_steps) { 
	j = -1;
	str += '<tr>';
	str += '<th>GCR: ' + gcr + '</th>';
	for (tilt = min_tilt ; tilt <= max_tilt ; tilt = tilt + tilt_steps) {
		j = j + 1;
		if (npv[i][j] == max_npv) str += '<td bgcolor = #00ff00>';
		else str += '<td>';
		str += ' ' + round(npv[i][j]) + ' '; 
		str += '</td>';
	}
	i = i + 1;
	str += '</tr>'; 
}

str += '</table>';


//Max Energy Yield Results:
str += '<br><br><h5>System Layout for Max Energy Yield: </h5>';
str += '<br>Max Energy Yield: '+ max_yield + ' kWh/kW';
str += '<br>Max Energy Yield Optmized GCR: '+ gcr_yield;
str += '<br>Optimal Tilt That Returns Max Energy Yield (In Degrees): ' + tilt_yield;
str += '<br>Max energy yield optimized system size: '+ system_size_yield + ' kW';
str += '<br>AEP at Max Energy Yield: '+ aep_yield + ' kWh ' ; 
str += '<br>Array Layout Configuration at max Energy Yield is: ';
str += '<br>Number of modules along bottom: ' + yield_nmodx +' modules'; 
str += '<br>Number of modules along side of each row (note: this was set by the user in the active case): ' + nmody + ' module(s)';
str += '<br>Number of rows: ' + yield_nrows + ' rows'; 
str += '<br>Row spacing estimate: ' + yield_row_spacing + ' m';
str += '<br>Total number of modules: ' + yield_total_modules + ' modules<br><br>';

//Table for Energy Yield Results:
str += '<br><br><strong>Energy Yield at Specified Combinations of GCR and Tilt Angles (kWh/kW): <br></strong>';
str += '<table>'; 
str += '<table border = "1">';
str += '<th> </th>';
for (tilt = min_tilt  ; tilt <= max_tilt ; tilt = tilt + tilt_steps)
{
	str += '<th>Tilt Angle: ' + tilt + '</th>';
}

i = 0;
for (gcr = min_gcr ; gcr <= max_gcr ; gcr = gcr + gcr_steps) { 
	j = -1;
	str += '<tr>';
	str += '<th>GCR: ' + gcr + '</th>';
	for (tilt = min_tilt ; tilt <= max_tilt ; tilt = tilt + tilt_steps) {
		j = j + 1;
		if (yield[i][j] == max_yield) str += '<td bgcolor = #00ff00>';
		else str += '<td>';
		str += ' ' + round(yield[i][j]) + ' '; 
		str += '</td>';
	}
	i = i + 1;
	str += '</tr>'; 
}

str += '</table>';




///////////////////////////////////**** P L O T T I N G ****///////////////////////////////////


//Plotting the AEP as a function of tilt angle (for various GCRs):
newplot();
for ( count = 0; count <= (#annual_energy - 1) ; count = count + 1) {
	type = [0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8, 0.9, 1.0];
	clr = ['red', 'green', 'blue', 'orange', 'yellow', 'brown', 'black', 'purple', 'pink', 'grey'];
	plot(x, annual_energy[count],{series = type[count], color = clr[count], size = 3});
	axis('x1', {'label' = "Tilt Angle "});
	axis('y1', {'label' = "Annual Energy Production  (kWh)"});
	plotopt({'legendpos'='right', 'coarse'=true, 'fine'=true, 'title' = "Annual Energy Production at Various GCR"});
}


//Plotting the NPV as a function of tilt angle (for various GCRs):
newplot();
for ( k = 0; k <= (#annual_energy - 1) ; k = k + 1) {
	type = [0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8, 0.9, 1.0];
	clr = ['red', 'green', 'blue', 'orange', 'yellow', 'brown', 'black', 'purple', 'pink', 'grey'];
	plot(x, npv[k],{series = type[k], color = clr[k], size = 3});
	axis('x1', {'label' = "Tilt Angle"});
	axis('y1', {'label' = "Net Present Value  ($)"});
	plotopt({'legendpos'='right', 'coarse'=true, 'fine'=true, 'title' = "Net Present Value at Various GCR"});
}


//Plotting the energy yield as a function of tilt angle (for various GCRs):
newplot();
for ( l = 0; l <= (#annual_energy - 1) ; l = l + 1) {
	type = [0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8, 0.9, 1.0];
	clr = ['red', 'green', 'blue', 'orange', 'yellow', 'brown', 'black', 'purple', 'pink', 'grey'];
	plot(x, yield[l],{series = type[l], color = clr[l], size = 3});   //This is the energy yield of the system
	axis('x1', {'label' = "Tilt Angle "});
	axis('y1', {'label' = "Energy Yield  (kWh/kW)"});
	plotopt({'legendpos'='right', 'coarse'=true, 'fine'=true, 'title' = "Energy Yield at Various GCR"});
}



///////////////////////////////////**** END OF SCRIPT****///////////////////////////////////

str += '</body></html>';
html_dialog(str, 'Optimal Array Layout', [1000,800]);


