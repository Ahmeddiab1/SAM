/*////////////////////////////////////////////////////////////////////////////////

Given a location name, street address, or latitude and longitude for a location 
in the NREL National Solar Radiation Database (NSRDB), this script prompts
you to select the data file(s) you want to download.

The script will also read a list of locations from a CSV file with either of
a list of addresses and location names, or of latitude and longitudes.

CSV format for list of addresses and location names:

address
lebanon or
paducah ky
"alexandia, va"
"1111 Rainbow St, Clarksville TN"

CSV format for list of latitudes and longitudes:

lat,lon
45,-112
40,-90
34,-110
33.4,-109.6

It replicates the functionality of the download button on the Location and
Resource page.

Click Run above to start the script.
 
Note: The NSRDB may return a file with an error message instead of weather data
if you exceed the the download rate limit or if there is a problem with the URL.

Written in SAM 2018.11.11, January 2019

//////////////////////////////////////////////////////////////////////////////*/

// folder to store weather files (script creates subfolder for each location).
path = choose_dir(wfdownloaddir(), 'Choose a Folder to Store Downloaded Files');

options = ['Download file for single location','Import list of locations from CSV file'];
location_option = choose_from_list( ['Download file for single location','Import list of locations from file'],'Choose one:','Single or Multiple Location',0);

site = {};
site.lat = []; 
site.lon = [];
site.name = [];

if ( location_option == options[0] )
{
	location = in( 'Enter a location name, street address, or lat,lon pair:','40.1,-109.3','Location Information');
	// function lat_lon ( location )
	// {
	lat_lon = geocode( location );
	if ( lat_lon.ok == false )
	{
		msgbox( 'Failed to convert location to latitude and longitude!\n' + location + '\n\nExiting script.');
		exit;
	}
	else
	{
		site.lat[0] = lat_lon.lat;
		site.lon[0] = lat_lon.lon;
		addr = lower(location);
		if ( isdigit(split(addr,',')[0]) )
		{
			addr = replace(location,',','_');
		}
		else
		{
			addr = replace(addr,',','-');
			addr = replace(addr,'.','-');
			addr = replace(addr,' ','-');
			addr = replace(addr,'--','-');
		}
		site.name[0] = addr;
	}
	// return T; // T.lat, T.lon
	// }

}
else
{
	location_file = choose_file( cwd(), 'Choose Location File', 'CSV files (*.csv)|*.csv');
	// given a file with a list of locations, return a table of locations
	// function get_location_list( location_file )
	// {
	locations = csvread(location_file,{'table'=true});
	keys = @locations;
	n_records = 0;
	if ( ( keys ?@ 'address' ) > -1 )
	{
		n_records = #locations.address;
		is_address = true;
	} 
	elseif ( ( keys ?@ 'lat' ) > -1 )
	{
		n_records = #locations.lat;
		is_address = false;
	}
	else
	{
		msgbox( 'CSV file must have first row "address" or "lat,lon"!\n' + keys + '\n\nExiting script.' );
	}
	// return T; // T.locations, T.is_address
	// }
	//For each site in lookup file
	for ( j=0; j<n_records; j++ )
	{
		// Geocode
		if ( is_address )
		{
			latlon = geocode(locations.address[j]);
			site.lat[j] = latlon.lat;
			site.lon[j] = latlon.lon;
			addr = lower(locations.address[j]);
			addr = replace(addr,',','-');
			addr = replace(addr,'.','-');
			addr = replace(addr,' ','-');
			addr = replace(addr,'--','-');
			site.name[j] = addr;
		}
		else 
		{
			site.lat[j] = locations.lat[j];
			site.lon[j] = locations.lon[j];
			site.name[j] = to_string(locations.lat[j]) + '_' + to_string(locations.lon[j]);
		}
	}	
}

// nsrdb query to determine what data is available for location
// https://developer.nrel.gov/docs/solar/nsrdb/nsrdb_data_query/
// var.outputs: array of tables for each dataset available for the location [{psm dataset},{psmv3 dataset},{mts1 dataset}...]
// var.outputs[x].availableYears: array ["tmy",2000,2001,2002,2003,2004,2005,2006,2007,2008,2009,2010,2011,2012,2013,2014]
// var.outputs[x].availableIntervals: array [30,60]
// var.outputs[x].links: array of tables [{year,interval,link},{year,interval,link},...]
// var.outputs[x].name: string version name 'suny-international','psmv3','mts1','mts2'

for ( s=0 ; s<#site.lat; s++ )
{
	// on first pass, get list of available versions and urls
	if ( s == 0 )
	{
		// given a lat,lon pair, return a table of available data and urls from the NSRDB
		// function nsrdb_query( lat, lon )
		// {
		base_url = 'http://developer.nrel.gov/api/solar/';
		query_url = 'nsrdb_data_query.json?api_key=<SAMAPIKEY>&wkt=POINT(' + to_string(site.lon[s]) + '+' + to_string(site.lat[s]) + ')';
		url = base_url + query_url;
		json_str = curl( url );
		var = json_read( json_str );

		if ( #var.errors > 0 )
		{
			msgbox( 'NSRDB Error!\n' + var.errors[0] + '\n\nFor location name ' + site.name[s] + '.\n\nExiting script.' );
			exit;
		}
		if (#var.outputs == 0)
		{
			msgbox( 'No NSRDB data found for location name ' + site.name[s] + '.\nNSRDB grid cell coordinates: Latitude = ' + site.lat[s] + ', Longitude = ' + site.lon[s] + '.\n\nExiting script.' );
			exit;
		}
		// return var;
		// }

		// get list of available versions and years
		for( i=0; i<#var.outputs; i++ )
		{
			available_versions[i] = var.outputs[i].name;
		}
		version = choose_from_list( available_versions, 'Choose an NSRDB version (Current version for Americas is psmv3:','Choose NSRDB Version' );
		for( i=0; i<#var.outputs; i++ )
		{
			if ( var.outputs[i].name == version )
			{
				links = var.outputs[i].links;
				available_years = var.outputs[i].availableYears;
				available_intervals = var.outputs[i].availableIntervals;
			}
		}
		years = available_years; // contains mix of numbers 2001, 2002, etc. and strings tmy, all
		if ( #years > 1 )
		{
			years[#years] = 'all';
		}	
		year = choose_from_list( years, 'Choose a year (Choose "all" to download all years for P50/P90 simulations:  ','Choose Year' );
		if ( ( year != 'all' ) && ( strpos( year, 'tmy' ) < 0 ) ) // mts1 versions uses 'tmy2' instead of 'tmy'
		{
			year = to_int( year );
		}
		if ( strpos( year, 'tmy' ) > -1 ) // only hourly data available for tmy
		{
			interval = 60;
		}
		else
		{
			interval = choose_from_list( available_intervals, 'Choose a the interval (time step) in minutes:  ','Choose Interval' );
			interval = to_int( interval );
		}	
	}

	// get download urls for all available versions, intervals, and years, create
	// file names for downloads
	wf = {};
	n = 0;
	for( i=0; i<#links; i++ )
	{
		if ( year == 'all' )
		{
			outln('get urls for all years');
		}
		elseif ( (links[i].year == year) && (links[i].interval == interval) )
		{
			url = links[i].link;
			outln(url);
			url = replace( url, 'yourapikey', '<SAMAPIKEY>' );
			url = replace( url, 'youremail', '' );
			wf.url[n] = url;
			wf.fname[n] = path + '/nsrdb_' + site.name[s] + '_' + site.lat[s] + '_' + site.lon[s] + '_' + interval + 'min_' + year + '.csv';
			n++;
		}
	}
}

outln( 'Number of available files = ' + #wf.url );

// download test file to get server error message from test file
ok = curl( wf.url[0], {'file' = wf.fname[0] } );
if ( !ok ) { outln( 'Test download failed.' ); }
else
{
	arr = csvread( wf.fname[0] );
	if ( #arr < 10 )
	{
		msgbox( 'Download Error!\n' + 'Message from NSRDB server: \n\n' +  arr + '\n\nExiting script.' ); 
		remove_file( wf.fname[0] );
		exit;
	}
	else { remove_file( wf.fname[0] ); }
}

// download requested files
n=0;
for( i=0; i<#wf.url; i++ )
{
		outln( 'Downloading data to ' + wf.fname[i] );
		outln( wf.url[i] );
		outln();
		ok = curl( wf.url[i], {'file' = wf.fname[i] } );
		if ( !ok ) { outln( '  Download failed.' ); }
		else { n++; }
}

outln( 'Done.' );
browse( path );
